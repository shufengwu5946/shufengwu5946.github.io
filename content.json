[{"title":"JavaScript 学习笔记","date":"2018-11-12T03:06:57.678Z","path":"2018/11/12/javascript/","text":"1 基本语法1.1 语句(略) 1.2 变量(略) 1.2.1 变量提升(略) 1.3 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 1.4 注释(略) 1.5 区块(略) 1.6 条件语句 if…else switch 三元运算符 (略) 1.7 循环语句(略) 1.7.1 for(略) 1.7.2 while(略) 1.7.3 do…while(略) 1.7.4 break和continue(略) 1.7.5 标签(label)(略) 2 数据类型2.1 类型JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 狭义的对象（object） 数组（array） 函数（function） 原始类型（primitive type）：数值、字符串、布尔值。 合成类型（complex type）：对象。 特殊值：null、undefined。 2.2 typeof 运算符typeof运算符可以返回一个值的数据类型。 123456789101112131415typeof 123 // \"number\" 数值返回numbertypeof '123' // \"string\" 字符串返回stringtypeof false // \"boolean\" 布尔值返回booleanfunction f() &#123;&#125;typeof f // \"function\" 函数返回functiontypeof undefined // \"undefined\" undefined返回undefined//对象返回objecttypeof window // \"object\"typeof &#123;&#125; // \"object\"typeof [] // \"object\"typeof null // \"object\" null返回object 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// \"undefined\" 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123;// ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === \"undefined\") &#123;// ...&#125; 2.3 null 和 undefined 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false');&#125;// null is falseundefined == null// true null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 1234Number(null) // 05 + null // 5Number(undefined) // NaN5 + undefined // NaN null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2.4 布尔值下列运算符会返回布尔值： 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 123456undefinednullfalse0NaN\"\"或''（空字符串） 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 2.5 数值（后续补充） 2.6 字符串2.6.1 用法单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12'key = \"value\"'\"It's a long journey\" HTML语言的属性值使用双引号，JavaScript语言的字符串只使用单引号。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \\long \\long \\string';longString// \"Long long long string\" 如果想输出多行字符串，有一种利用多行注释的变通方法。12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\\n').slice(1, -1).join('\\n')// \"line 1// line 2// line 3\" 2.6.2 转义(后续补充) 2.6.3 字符串与数组 字符串可以被视为字符数组。 1234567var s = 'hello';s[0] // \"h\"s[1] // \"e\"s[4] // \"o\"// 直接对字符串使用方括号运算符'hello'[1] // \"e\" 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123'abc'[3] // undefined'abc'[-1] // undefined'abc'['x'] // undefined 无法改变字符串之中的单个字符。12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 2.6.4 字符集（后续补充） 2.6.5 Base 64转码（后续补充） 2.7 对象2.7.1 含义键名 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。 如果键名是数值，会被自动转为字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的引用o1和o2指向同一个对象，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 表达式还是语句？1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。 第一种可能是，这是一个表达式，表示一个包含foo属性的对象； 第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定： 如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号: 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2.7.2 属性的操作属性的读取12345678910111213141516171819202122var foo = 'bar';var obj = &#123; p: 'Hello World', bar: 2, 'hello world':3, 6:'num_key', 0.7: 'Hello World', 123: 'hello 123'&#125;;obj.p // \"Hello World\" 使用点运算符obj['p'] // \"Hello World\" 方括号运算符,键名必须放在引号里面，否则会被当作变量处理。obj[foo] // 2 键名为变量// 方括号运算符内部还可以使用表达式obj['hello' + ' world'] //3obj[3 + 3] //num_key// 数字键可以不加引号，因为会自动转成字符串。obj['0.7'] // \"Hello World\"obj[0.7] // \"Hello World\"obj.123 // 报错 数值键名不能使用点运算符obj[123] // \"hello 123\" 属性的赋值（略） 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。12Object.keys(obj);// [\"6\", \"123\", \"p\", \"bar\", \"hello world\", \"0.7\"] 属性的删除1delete obj.p // true 删除一个不存在的属性，delete不报错，而且返回true 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 12345var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, configurable: false&#125;);delete obj.p // false delete命令只能删除对象本身的属性，无法删除继承的属性,虽然delete命令返回true，但该属性并没有被删除，依然存在。 in 运算符————属性是否存在123var obj = &#123; p: 1 &#125;;'p' in obj // true'toString' in obj // true in运算符不能区分哪些属性是对象自身的，还是继承的。 就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断是否为对象自身的属性。 for…in ————属性的遍历1234567891011var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 两个使用注意点: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 只想遍历对象自身的属性，结合使用hasOwnProperty方法：12345for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125; 2.7.3 with语句操作同一个对象的多个属性时，提供一些书写的方便。 不推荐使用！！！ 函数运算符标准库面向对象编程异步操作DOM事件浏览器模型","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用Hexo+Github.io构建自己的博客","date":"2018-11-03T16:00:00.000Z","path":"2018/11/04/Hexo-Github-io-blog/","text":"背景知识Github Page是什么Github是全球最大的开源社区，Github Page是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上。 Hexo是什么你可以将你的静态页面直接放在Github Page上，也可以用Hexo或者Jekyll等博客框架自动生成站点。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 基础构建步骤1、 安装Node.js，并配置好Node.js环境。 2、 安装Git，并配置好Git环境。 3、 如果没有Github账户，先注册Github账户，然后新建项目，项目必须要遵守格式:“Github账户名.github.io”，这样能够防止接下来的很多麻烦。访问“http://Github账户名.github.io” ，发现网址已经可以通过网络访问。 4、 安装Hexo。 ① 安装Hexo，在自己认为合适的地方创个文件夹，例如在E盘创建hexo_test文件夹。然后通过cd命令行进入到该文件夹里面。 ② 输入npm install hexo -g，开始安装Hexo。安装完成后可以输入hexo -v，检查hexo是否安装成功，安装成功会有类似如下输出： ③ 输入hexo init，初始化该文件夹,看到输出“Start blogging with Hexo！”，表明初始化成功： ④ 输入npm install，安装所需要的组件，等待安装完成。 ⑤ 输入hexo g，生成网站静态文件。 ⑥ 输入hexo s，开启本地服务器： 端口号存在被占用的可能，可以在服务器停止的情况下，输入“hexo server -p 端口号”来改变端口号。按照上面提示，在浏览器访问http://localhost:4000/，打开类似下图网页，证明Hexo本地服务器启动成功。 (未完待续)参考资料https://blog.csdn.net/peterzhen40/article/details/78942293 https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/cf0628478a4e","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github.io","slug":"Github-io","permalink":"http://yoursite.com/tags/Github-io/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"React 学习笔记","date":"2018-11-03T06:52:11.000Z","path":"2018/11/03/React/","text":"","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"webpack 学习笔记（一）","date":"2018-11-03T06:52:11.000Z","path":"2018/11/03/webpack_1/","text":"本文主要参考文章： 《入门 Webpack，看这篇就够了》 开始使用Webpack我们一步步的开始学习使用Webpack。 安装新建一个空的练习文件夹（此处命名为webpack-base-demo）。 切换到webpack-base-demo文件夹，在终端中使用npm init命令可以自动创建package.json文件，package.json文件这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。 1npm init 输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。 package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包12345// 安装Webpacknpm install --save-dev webpack// 安装webpack-clinpm install --save-dev webpack-cli 回到webpack-base-demo文件夹，并在里面创建app文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，接下来我们在app文件夹中创建两个文件: 12index.jsindex.css index.js文件内容： 123window.onload = function()&#123; document.getElementById('div1').textContent=\"Hello world\";&#125; 在webpack-base-demo文件夹里面创建dist文件夹，dist文件夹中创建index.html，index.html文件中写入最基础的html代码： 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" class=\"div1\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。 继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。 1234567module.exports = &#123; entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 在package.json中对scripts对象进行相关设置即可，设置方法如下。 12345678910111213141516&#123; \"name\": \"webpack-base-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^4.25.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125; 注：package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build。 现在只需要使用npm start就可以打包文件了,可以发现在dist文件夹中生成了index.js文件。 Webpack的强大功能生成Source Maps（使调试更容易）开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，Source Maps就是来帮我们解决这个问题的。 通过简单的配置，webpack就可以在打包时为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。 在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； 正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。 对小到中型的项目中，eval-source-map是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的webpack.config.js，进行如下配置: 12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", output: &#123; path: __dirname + \"/dist\", filename: \"index.js\" &#125;&#125; cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。 使用webpack构建本地服务器想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖 1npm install --save-dev webpack-dev-server devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考这里 devserver的配置选项 功能描述 contentBase 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“dist”目录） port 设置默认监听端口，如果省略，默认为”8080“ inline 设置为true，当源文件改变时会自动刷新页面 historyApiFallback 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html 把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示 1234567891011121314module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", output: &#123; path: __dirname + \"/dist\", filename: \"index.js\" &#125;, devServer: &#123; contentBase: \"./dist\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125; &#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\", \"server\": \"webpack-dev-server --open --mode development\"&#125;, 在终端中输入npm run server即可在本地的8080端口查看结果,成功后页面显示“Hello world”。 LoadersLoaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 不过在配置loader之前，我们把index.js里的“Hello world”放在一个单独的JSON文件里,并通过合适的配置使index.js可以读取该JSON文件的值，各文件修改后的代码如下： 在app文件夹中创建带有问候信息的JSON文件(命名为config.json) 123&#123; \"greetText\": \"Hello world\"&#125; 更新后的index.js 1234import config from './config.json';window.onload = function()&#123; document.getElementById('div1').textContent=config.greetText;&#125; 注 由于webpack4. / webpack3. / webpack2. 已经内置可处理JSON文件，这里我们无需再添加webpack1.需要的json-loader。在看如何具体使用loader之前我们先看看Babel是什么？ BabelBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的： 让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持； 让你能使用基于JavaScript进行了拓展的语言，比如React的JSX； Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包，用得最多的是解析Es6的babel-env-preset包。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env 在webpack中配置Babel的方法如下: 12345678910111213141516171819202122232425262728module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.js)$/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"env\" ] &#125; &#125;, exclude: /node_modules/ &#125;] &#125;&#125; 现在你的webpack的配置已经允许你使用ES6了，运行npm start，提示如下错误：12345678ERROR in ./app/index.jsModule build failed (from ./node_modules/babel-loader/lib/index.js):Error: Cannot find module '@babel/core' babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to use Babel6.x ('babel-core'), you should install 'babel-loader@7'. at Function.Module._resolveFilename (module.js:547:15) at Function.Module._load (module.js:474:25) at Module.require (module.js:596:17) 原因是版本babel-loader的版本为8.x，匹配的Babel的版本为7.x，查看package.json文件，babel-core的版本为6.26.3，我们采取的解决办法是将重新安装版本为7.x的babel-loader，重新运行npm start 就没问题了。 增加React的支持安装解析JSX的babel-preset-react包： 1npm install --save-dev babel-preset-react webpack.config.js中更新module如下： 1234567891011121314module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"env\", \"react\" ] &#125; &#125;, exclude: /node_modules/ &#125;]&#125; 现在webpack的配置已经允许使用JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM1npm install --save-dev react react-dom 接下来我们使用ES6的语法，APP文件夹中新建Greeter.js文件并返回一个React组件123456789101112131415//Greeter.jsimport React, &#123;Component&#125; from 'react'import config from './config.json';class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 修改index.js如下，使用ES6的模块定义和渲染Greeter模块 123456// index.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';render(&lt;Greeter /&gt;, document.getElementById('div1')); 重新使用npm start打包，并且运行npm run server，你应该可以在localhost:8080下看到与之前一样的内容，这说明react被正常打包了。 Babel的配置Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：123456789101112131415161718192021222324module.exports = &#123; entry: __dirname + \"/app/index.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\",//打包后的文件存放的地方 filename: \"index.js\"//打包后输出文件的文件名 &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: \"./dist\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125; ] &#125;&#125;; 1234//.babelrc&#123; \"presets\": [\"react\", \"env\"]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 一切皆模块Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子12//安装npm install --save-dev style-loader css-loader 1234567891011121314151617181920212223242526//使用module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125; ] &#125;&#125;; 请注意这里对同一个文件引入多个loader的方法。 接下来，在app文件夹里的index.css文件中，对一些元素设置样式 1234/* index.css */div&#123; color:green;&#125; 我们这里例子中用到的webpack只有单一的入口，其它的模块需要通过 import, require, url等与入口文件建立其关联，为了让webpack能找到index.css文件，我们把它导入index.js中，如下 1234567//index.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';import './index.css'; //使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById('div1')); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 上面的代码说明webpack是怎么把css当做模块看待的，咱们继续看一个更加真实的css模块实践。 CSS module在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。 不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。 被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下123456789101112131415161718192021222324252627282930module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125; ] &#125;&#125;; 我们在app文件夹下创建一个Greeter.css文件来进行一下测试1234/* Greeter.css */.by&#123; background-color: yellow;&#125; 导入.root到Greeter.js中123456789101112131415import React, &#123;Component&#125; from 'react';import config from './config.json';import styles from './Greeter.css';//导入class Greeter extends Component&#123; render() &#123; return ( &lt;div className=&#123;styles.by&#125;&gt; //使用cssModule添加类名的方法 &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 重新运行npm start打包，运行npm run server，打开localhost:8080，文字背景变为黄色，div的class为“Greeter__by–U44rR”这样的形式，这样就可以保证不同组件之间不会存在相同的类名。 CSS预处理器(后续补充) 插件（Plugins）插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件(https://webpack.js.org/plugins/)，可以让我们完成更加丰富的功能。 使用插件的方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件BannerPlugin。123456789101112131415161718192021222324252627282930const webpack = require('webpack'); //引入webpackmodule.exports = &#123;... module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究') ],&#125;; 通过这个插件，打包后的JS文件显示如下 1234567/*! 版权所有，翻版必究 *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123; 这就是webpack插件的基础用法了，下面给大家推荐几个常用的插件. HtmlWebpackPlugin这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。 安装1npm install --save-dev html-webpack-plugin 这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改： 移除dist文件夹，利用此插件，index.html文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。 在app目录下，创建一个index.tmpl.html文件模板，这个模板包含title等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，index.tmpl.html中的模板源代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" class=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 更新webpack的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ],&#125; 再次执行npm start你会发现，dist文件夹会重新生成，并文件夹下面生成了index.js和index.html。 Hot Module Replacement（后续补充） 产品阶段的构建目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。 对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个webpack.production.config.js的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'null', //注意修改了这里，这能大大压缩我们的打包代码 entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ],&#125; 123456789101112131415161718192021222324252627282930//package.json&#123; \"name\": \"webpack-base-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\", \"server\": \"webpack-dev-server --open --mode development\", \"build\": \"NODE_ENV=production webpack --config ./webpack.production.config.js --progress\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-preset-env\": \"^1.7.0\", \"babel-preset-react\": \"^6.24.1\", \"css-loader\": \"^1.0.1\", \"html-webpack-plugin\": \"^3.2.0\", \"react\": \"^16.6.1\", \"react-dom\": \"^16.6.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.25.1\", \"webpack-cli\": \"^3.1.2\", \"webpack-dev-server\": \"^3.1.10\" &#125;, \"dependencies\": &#123;&#125;&#125; 注意：如果是window电脑，build需要配置为”build”: “set NODE_ENV=production &amp;&amp; webpack –config ./webpack.production.config.js –progress”。谢谢评论区简友提醒。 优化插件webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能 OccurenceOrderPlugin：为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID UglifyjsWebpackPlugin：压缩JS代码； ExtractTextPlugin：分离CSS和JS文件（暂时不支持webpack 4，本文档不予讨论） 我们继续用例子来看看如何添加它们，OccurenceOrder是内置插件，你需要做的只是安装其它非内置插件 1npm install --save-dev uglifyjs-webpack-plugin 在配置文件的plugins后引用它们1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');// extract-text-webpack-plugin暂时不支持webpack4// const ExtractTextPlugin = require('extract-text-webpack-plugin');const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; devtool: 'null', //注意修改了这里，这能大大压缩我们的打包代码 entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new UglifyjsWebpackPlugin(), // extract-text-webpack-plugin暂时不支持webpack4 // new ExtractTextPlugin(\"style.css\"), ],&#125; 此时执行npm run build可以看见代码是被压缩后的。 缓存缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变） webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前 12345678910111213141516// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');// extract-text-webpack-plugin暂时不支持webpack4// const ExtractTextPlugin = require('extract-text-webpack-plugin');const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123;... entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index-[hash].js\" //打包后输出文件的文件名 &#125;, ...&#125; 现在用户会有合理的缓存了。 去除dist文件中的残余文件添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件clean-webpack-plugin。 安装： 1npm install clean-webpack-plugin --save-dev 使用： 引入clean-webpack-plugin插件后在配置文件的plugins中做相应配置即可： 123456789const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); plugins: [ ...// 这里是之前配置的其它各种插件 new CleanWebpackPlugin('dist/*.*', &#123; root: __dirname, verbose: true, dry: false &#125;) ] 关于clean-webpack-plugin的详细使用可参考这里。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]}]