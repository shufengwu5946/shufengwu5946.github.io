[{"title":"JavaScript学习笔记（五）——面向对象编程","date":"2018-11-19T03:04:47.580Z","path":"2018/11/19/javascript_5/","text":"来自教程 https://wangdoc.com/javascript/basic/index.html 6 面向对象编程实例对象与 new 命令new 命令直接调用构造函数存在问题如果忘了使用new命令，直接调用构造函数，构造函数就变成了普通函数，并不会生成实例对象，这时，构造函数中的this这时代表全局对象 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 解决方案：方案一：为了保证构造函数必须与new命令一起使用，构造函数内部使用严格模式。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 12345678function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property '_foo' of undefined 由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。 方案二：构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 手写new命令 123456789101112131415function _new( constructor, params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === 'object' &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, '张三', 28); new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 使用这个属性，可以判断函数调用的时候，是否使用new命令。12345678function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ Object.create() 创建实例对象有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。1var person2 = Object.create(person1); 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 this关键字涵义由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 12345678910111213141516function f() &#123; return '姓名：'+ this.name;&#125;var A = &#123; name: '张三', describe: f&#125;;var B = &#123; name: '李四', describe: f&#125;;A.describe() // \"姓名：张三\"B.describe() // \"姓名：李四\" 函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。12345678910var A = &#123; name: '张三', describe: function () &#123; return '姓名：'+ this.name; &#125;&#125;;var name = '李四';var f = A.describe;f() // \"姓名：李四\" 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 实质JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 { foo: { [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true }} 注意，foo属性的值保存在属性描述对象的value属性里面。 这样的结构是很清晰的，问题在于属性的值可能是一个函数。1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 { foo: { [[value]]: 函数的地址 … }} 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 使用场合this主要有以下几个使用场合。 （1）全局环境 全局环境使用this，它指的就是顶层对象window。 （2）构造函数 构造函数中的this，指的是实例对象。 （3）对象的方法 如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 但是，这条规则很不容易把握。请看下面的代码。1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，下面这几种用法，都会改变this的指向。123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。12345678910var a = &#123; p: 'Hello', b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。 123456789101112var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: 'Hello', b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。12var hello = a.b;hello.m() // Hello 使用注意点避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。 123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。 12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; 'use strict'; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property 'count' of undefined 上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。12345678910111213var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。1234567891011121314var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+' '+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。12345678910111213var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + ' ' + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;// jQuery 的写法$('#button').on('click', o.f) 上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 绑定 this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。 如果参数为空、null和undefined，则默认传入全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 call方法的一个应用是调用对象的原生方法。 12345678910var obj = &#123;&#125;;obj.hasOwnProperty('toString') // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty('toString') // trueObject.prototype.hasOwnProperty.call(obj, 'toString') // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 利用这一点，可以做一些有趣的应用。 （1）找出数组最大元素 JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。12var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15 （2）将数组的空元素变为undefined 通过apply方法，利用Array构造函数将数组的空元素变成undefined。12Array.apply(null, ['a', ,'b'])// [ 'a', undefined, 'b' ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 1234567891011121314var a = ['a', , 'b'];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b （3）转换类似数组的对象 另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 1234Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]Array.prototype.slice.apply(&#123;0: 1&#125;) // []Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 （4）绑定回调函数的对象 前面的按钮点击事件的例子，可以改写如下。12345678910111213var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;// jQuery 的写法$('#button').on('click', f); 上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题。12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。 this绑定到其他对象也是可以的。12345678910111213var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。1234567891011var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 bind方法有一些使用注意点。 （1）每一次返回一个新函数 bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。1element.addEventListener('click', o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。1element.removeEventListener('click', o.m.bind(o)); 正确的方法是写成下面这样：1234var listener = o.m.bind(o);element.addEventListener('click', listener);// ...element.removeEventListener('click', listener); （2）结合回调函数使用 回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。 1234567891011121314var counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 123456789101112var obj = &#123; name: '张三', times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 （3）结合call方法使用 利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。 123[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。 12var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法。 123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。 1234567function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码的含义就是，将Function.prototype.bind方法绑定在Function.prototype.call上面，所以bind方法就可以直接使用，不需要在函数实例上使用。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript学习笔记（四）——标准库","date":"2018-11-14T07:58:16.876Z","path":"2018/11/14/javascript_4/","text":"来自教程 https://wangdoc.com/javascript/basic/index.html 5 标准库5.1 Object对象5.1.1 Object()如果参数为空（或者为undefined和null），Object()返回一个空对象。123456var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。1234567891011var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object('foo');obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。1234567891011var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 5.1.2 Object构造函数 通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。 但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。 5.1.3 Object静态方法Object.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。方法的参数都是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。 Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。 其他方法（1）对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。 （2）控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。 （3）原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。 5.1.4 Object实例方法Object实例对象的方法，主要有以下六个。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 toString() 的应用：判断数据类型由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。1Object.prototype.toString.call(value) 上面代码表示对value这个值调用Object.prototype.toString方法。 不同数据类型的Object.prototype.toString方法返回值如下。 数值：返回[object Number]。 字符串：返回[object String]。 布尔值：返回[object Boolean]。 undefined：返回[object Undefined]。 null：返回[object Null]。 数组：返回[object Array]。 arguments 对象：返回[object Arguments]。 函数：返回[object Function]。 Error 对象：返回[object Error]。 Date 对象：返回[object Date]。 RegExp 对象：返回[object RegExp]。 其他对象：返回[object Object]。这就是说，Object.prototype.toString可以看出一个值到底是什么类型。 5.2 属性描述对象5.2.1 概述下面是属性描述对象的一个例子。12345678&#123; value: 123, writable: false, enumerable: true, configurable: false, get: undefined, set: undefined&#125; 属性描述对象提供6个元属性。 （1）value value是该属性的属性值，默认为undefined。 （2）writable writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 （3）enumerable enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for…in循环、Object.keys()）跳过该属性。 （4）configurable configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 （5）get get是一个函数，表示该属性的取值函数（getter），默认为undefined。 （6）set set是一个函数，表示该属性的存值函数（setter），默认为undefined。 5.2.2 Object.getOwnPropertyDescriptor()只能用于对象自身的属性，不能用于继承的属性。 5.2.3 Object.getOwnPropertyNames()方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历，不返回继承的属性。 这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 5.2.4 Object.defineProperty()，Object.defineProperties()Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。 1Object.defineProperty(object, propertyName, attributesObject) Object.defineProperty方法接受三个参数，依次如下。 object：属性所在的对象 propertyName：字符串，表示属性名 attributesObject：属性描述对象 如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。 5.2.5 Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable()方法返回一个布尔值，用来判断某个属性是否可遍历。 注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。 5.2.6 元属性（1）value（略） （2）writable如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。123456789var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);obj.foo = 'b';obj.foo // 'a' 但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。 1234567891011var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);Object.defineProperty(obj, 'foo', &#123; value: 'b'&#125;);obj.foo // \"b\" （3） enumerable如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环 Object.keys方法 JSON.stringify方法 只有可遍历的属性，才会被for…in循环遍历，同时还规定toString这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了for…in循环的可用性。 for…in循环包括继承的属性 Object.keys方法不包括继承的属性 如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法。 （4）configurableconfigurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，configurable为false时，value、writable、enumerable和configurable都不能被修改了。 writable只有在false改为true会报错，true改为false是允许的。 至于value，只要writable和configurable有一个为true，就允许改动。 另外，configurable为false时，直接目标属性赋值，不报错，但不会成功。如果是严格模式，还会报错。 可配置性决定了目标属性是否可以被删除（delete）。 5.2.7 存取器5.2.8 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。123456789101112var extend = function (to, from) &#123; for (var property in from) &#123; to[property] = from[property]; &#125; return to;&#125;extend(&#123;&#125;, &#123; a: 1&#125;)// &#123;a: 1&#125; 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。1234extend(&#123;&#125;, &#123; get a() &#123; return 1 &#125;&#125;)// &#123;a: 1&#125; 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。123456789101112131415var extend = function (to, from) &#123; for (var property in from) &#123; if (!from.hasOwnProperty(property)) continue; Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;)// &#123; get a()&#123; return 1 &#125; &#125;) 上面代码中，hasOwnProperty那一行用来过滤掉继承的属性，否则会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。 5.2.8 控制对象状态（1）Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 （2）Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。 （3）Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。 Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。 Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值，此时p属性的可写性由writable决定。 （4）Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。 这时，Object.isExtensible方法也返回false。 （5）Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。如果在严格模式下，则会报错。 （6）Object.isFrozen()Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 Object.isFrozen的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。 5.2.9 局限性上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。 一种解决方案是，把obj的原型也冻结住。 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。 5.3 Array对象5.3.1 构造函数Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。12345678910111213141516171819// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array('abc') // ['abc']new Array([1]) // [Array[1]]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c'] 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。12345// badvar arr = new Array(1, 2);// goodvar arr = [1, 2]; 注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。 5.3.2 静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 5.3.3 实例方法（1） valueOf()，toString()数组的valueOf方法返回数组本身。 数组的toString方法返回数组的字符串形式。 （2）push()，pop()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 注意，该方法会改变原数组。 pop方法用于删除数组的最后一个元素，并返回该元素。 注意，该方法会改变原数组。 对空数组使用pop方法，不会报错，而是返回undefined。 push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 （3）shift()，unshift()shift()方法用于删除数组的第一个元素，并返回该元素。 注意，该方法会改变原数组。 shift()方法可以遍历并清空一个数组。 push()和shift()结合使用，就构成了“先进先出”的队列结构（queue）。 unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 注意，该方法会改变原数组。 unshift()方法可以接受多个参数，这些参数都会添加到目标数组头部。 （4）join()join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 如果数组成员是undefined或null或空位，会被转成空字符串。 通过call方法，这个方法也可以用于字符串或类似数组的对象。123456Array.prototype.join.call('hello', '-')// \"h-e-l-l-o\"var obj = &#123; 0: 'a', 1: 'b', length: 2 &#125;;Array.prototype.join.call(obj, '-')// 'a-b' （5）concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 （6）reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。 注意，该方法将改变原数组。 （7）slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 1arr.slice(start, end); 如果slice方法的参数是负数，则表示倒数计算的位置。 123var a = ['a', 'b', 'c'];a.slice(-2) // [\"b\", \"c\"]a.slice(-2, -1) // [\"b\"] 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 slice方法的一个重要应用，是将类似数组的对象转为真正的数组。12345Array.prototype.slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;)// ['a', 'b']Array.prototype.slice.call(document.querySelectorAll(\"div\"));Array.prototype.slice.call(arguments); （8）splice()splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。 注意，该方法会改变原数组。1arr.splice(start, count, addElement1, addElement2, ...); splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 起始位置如果是负数，就表示从倒数位置开始删除。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 （9）sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较。 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 （10）map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回，原数组没有变化。 map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。1234[1, 2, 3].map(function(elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] 上面代码中，map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）。 map方法还可以接受第二个参数，用来绑定回调函数内部的this变量（详见《this 变量》一章）。 12345var arr = ['a', 'b', 'c'];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// ['b', 'c'] 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 map方法不会跳过undefined和null，但是会跳过空位。 （11）forEach()forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。 forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。 forEach方法也可以接受第二个参数，绑定参数函数的this变量。 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 forEach方法也会跳过数组的空位。 forEach方法不会跳过undefined和null，但会跳过空位。 （12）filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。 该方法不会改变原数组。 filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。 filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 （13）some()，every()这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。 它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 （14）reduce()，reduceRight()reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 [1, 2, 3, 4, 5].reduce(function (a, b) { console.log(a, b); return a + b;})// 1 2// 3 3// 6 4// 10 5//最后结果：15上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。 reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。 累积变量，默认为数组的第一个成员当前变量，默认为数组的第二个成员当前位置（从0开始）原数组这四个参数之中，只有前两个是必须的，后两个则是可选的。 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。 [1, 2, 3, 4, 5].reduce(function (a, b) { return a + b;}, 10);// 25上面代码指定参数a的初值为10，所以数组从10开始累加，最终结果为25。注意，这时b是从数组的第一个成员开始遍历。 上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。 function add(prev, cur) { return prev + cur;} [].reduce(add)// TypeError: Reduce of empty array with no initial value[].reduce(add, 1)// 1上面代码中，由于空数组取不到初始值，reduce方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。 下面是一个reduceRight方法的例子。 function substract(prev, cur) { return prev - cur;} [3, 2, 1].reduce(substract) // 0[3, 2, 1].reduceRight(substract) // -4上面代码中，reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。 function findLongest(entries) { return entries.reduce(function (longest, entry) { return entry.length &gt; longest.length ? entry : longest; }, ‘’);} findLongest([‘aaa’, ‘bb’, ‘c’]) // “aaa”上面代码中，reduce的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 var a = [‘a’, ‘b’, ‘c’]; a.indexOf(‘b’) // 1a.indexOf(‘y’) // -1indexOf方法还可以接受第二个参数，表示搜索的开始位置。 [‘a’, ‘b’, ‘c’].indexOf(‘a’, 1) // -1上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。 [NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。 链式使用上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。 var users = [ {name: ‘tom’, email: &#39;tom@example.com‘}, {name: ‘peter’, email: &#39;peter@example.com‘}]; users.map(function (user) { return user.email;}).filter(function (email) { return /^t/.test(email);}).forEach(function (email) { console.log(email);});// “tom@example.com“上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以t开头的 Email 地址，最后将它打印出来。 5.4 包装对象5.5 Boolean对象5.6 Number 对象5.7 String 对象5.8 Math 对象5.9 Date 对象5.10 RegExp 对象5.11 JSON 对象6 面向对象编程7 异步操作8 DOM事件浏览器模型","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript学习笔记（三）——语法专题","date":"2018-11-14T06:03:35.743Z","path":"2018/11/14/javascript_3/","text":"来自教程 https://wangdoc.com/javascript/basic/index.html 4 语法专题4.1 数据类型的转换4.1.1 强制转换Number()（1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number('324') // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber('324abc') // NaN// 空字符串转为0Number('') // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt('42 cats') // 42Number('42 cats') // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt('\\t\\v\\r12.34\\n') // 12Number('\\t\\v\\r12.34\\n') // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 Number背后的转换规则: 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 String()（1）原始类型值 数值：转为相应的字符串。 字符串：转换后还是原来的值。 布尔值：true转为字符串”true”，false转为字符串”false”。 undefined：转为字符串”undefined”。 null：转为字符串”null”。 （2）对象 String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 Boolean()转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 undefined null -0或+0 NaN‘’（空字符串） 4.1.1 自动转换自动转换为字符串12345678910111213'5' + 1 // '51''5' + true // \"5true\"'5' + false // \"5false\"'5' + &#123;&#125; // \"5[object Object]\"'5' + [] // \"5\"'5' + function ()&#123;&#125; // \"5function ()&#123;&#125;\"'5' + undefined // \"5undefined\"'5' + null // \"5null\"var obj = &#123; width: '100'&#125;;obj.width + 20 // \"10020\" 自动转换为数值123456789101112131415'5' - '2' // 3'5' * '2' // 10true - 1 // 0false - 1 // -1'1' - 1 // 0'5' * [] // 0false / '5' // 0'abc' - 1 // NaNnull + 1 // 1undefined + 1 // NaN+'abc' // NaN-'abc' // NaN+true // 1-false // 0 4.2 错误处理机制(未完待续) 4.3 编程风格（未完待续） 4.4 console对象与控制台（未完待续）","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript学习笔记（二）——运算符","date":"2018-11-13T09:03:44.342Z","path":"2018/11/13/javascript_2/","text":"来自教程 https://wangdoc.com/javascript/basic/index.html 3 运算符JavaScript 共提供10个算术运算符，用来完成基本的算术运算。 加法运算符：x + y 减法运算符： x - y 乘法运算符： x * y 除法运算符：x / y 指数运算符：x ** y 余数运算符：x % y 自增运算符：++x 或者 x++ 自减运算符：–x 或者 x– 数值运算符： +x 负数值运算符：-x 3.1 加法运算符3.1.1 基本规则1234true + true // 21 + true // 2'3' + 4 + 5 // \"345\"3 + 4 + '5' // \"75\" 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。1231 - '2' // -11 * '2' // 21 / '2' // 0.5 3.1.2 对象的相加如果运算子是对象，必须先转成原始类型的值，然后再相加。12var obj = &#123; p: 1 &#125;;obj + 2 // \"[object Object]2\" 上面代码中，对象obj转成原始类型的值是[object Object]，再加2就得到了上面的结果。 对象转成原始类型的值，规则如下。1obj.valueOf().toString() 知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。1234567var obj = &#123; valueOf: function () &#123; return 1; &#125;&#125;;obj + 2 // 3 1234567var obj = &#123; toString: function () &#123; return 'hello'; &#125;&#125;;obj + 2 // \"hello2\" 特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。12345var obj = new Date();obj.valueOf = function () &#123; return 1 &#125;;obj.toString = function () &#123; return 'hello' &#125;;obj + 2 // \"hello2\" 1237+null //77+undefined //NaN7+NaN //NaN 3.1.3 数值运算符，负数值运算符数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。123+true // 1+[] // 0+&#123;&#125; // NaN 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。 123var x = 1;-x // -1-(-x) // 1 数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。 3.1.4 指数运算符指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 3.2 比较运算符JavaScript 一共提供了8个比较运算符。 大于运算符 &lt; 小于运算符 &lt;= 小于或等于运算符 = 大于或等于运算符 == 相等运算符 === 严格相等运算符 != 不相等运算符 !== 严格不相等运算符 3.2.1 非相等运算符：非字符串的比较（1）原始类型值 如果两个运算子都是原始类型的值，则是先转成数值再比较。 12345678910115 &gt; '4' // true// 等同于 5 &gt; Number('4')// 即 5 &gt; 4true &gt; false // true// 等同于 Number(true) &gt; Number(false)// 即 1 &gt; 02 &gt; true // true// 等同于 2 &gt; Number(true)// 即 2 &gt; 1 任何值（包括NaN本身）与NaN比较，返回的都是false。 （2）对象如果运算子是对象，会转为原始类型的值，再进行比较。 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法123456789101112131415161718192021var x = [2];x &gt; '11' // true// 等同于 [2].valueOf().toString() &gt; '11'// 即 '2' &gt; '11'x.valueOf = function () &#123; return '1' &#125;;x &gt; '11' // false// 等同于 [2].valueOf() &gt; '11'// 即 '1' &gt; '11'[2] &gt; [1] // true// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()// 即 '2' &gt; '1'[2] &gt; [11] // true// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()// 即 '2' &gt; '11'&#123; x: 2 &#125; &gt;= &#123; x: 1 &#125; // true// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()// 即 '[object Object]' &gt;= '[object Object]' 3.2.2 严格相等运算符JavaScript提供两种相等运算符：==和===。 区别： 相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。 如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。 使用： 不同类型的值：如果两个值的类型不同，直接返回false 同一类的原始类型值：同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。 复合类型值：两个复合类型（对象、数组、函数）的数据比较时，是比较它们是否指向同一个地址。 NaN与任何值都不相等（包括自身）。另外，正0等于负0 undefined 和 null：undefined和null与自身严格相等。12undefined === undefined // truenull === null // true 3.2.3 相等运算符 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。 比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。 （1）原始类型值原始类型的值会转换成数值再进行比较。1234567891011121314151617181920212223242526272829301 == true // true// 等同于 1 === Number(true)0 == false // true// 等同于 0 === Number(false)2 == true // false// 等同于 2 === Number(true)2 == false // false// 等同于 2 === Number(false)'true' == true // false// 等同于 Number('true') === Number(true)// 等同于 NaN === 1'' == 0 // true// 等同于 Number('') === 0// 等同于 0 === 0'' == false // true// 等同于 Number('') === Number(false)// 等同于 0 === 0'1' == true // true// 等同于 Number('1') === Number(true)// 等同于 1 === 1'\\n 123 \\t' == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 （2）对象与原始类型值比较对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。123456789101112131415// 对象与数值比较时，对象转为数值[1] == 1 // true// 等同于 Number([1]) == 1// 对象与字符串比较时，对象转为字符串[1] == '1' // true// 等同于 String([1]) == '1'[1, 2] == '1,2' // true// 等同于 String([1, 2]) == '1,2'// 对象与布尔值比较时，两边都转为数值[1] == true // true// 等同于 Number([1]) == Number(true)[2] == true // false// 等同于 Number([2]) == Number(true) （3）undefined 和 nullundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。1234567false == null // falsefalse == undefined // false0 == null // false0 == undefined // falseundefined == null // true （4）相等运算符的缺点相等运算符隐藏的类型转换，会带来一些违反直觉的结果。12345678910111213140 == '' // true0 == '0' // true2 == true // false2 == false // falsefalse == 'false' // falsefalse == '0' // truefalse == undefined // falsefalse == null // falsenull == undefined // true' \\t\\r\\n ' == 0 // true 3.3 布尔运算符四个运算符。 取反运算符：! 且运算符：&amp;&amp; 或运算符：|| 三元运算符：?: 3.3.1 取反运算符（!）以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（’’） 3.3.2且运算符（&amp;&amp;） 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。 3.3.3 或运算符（||） 它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。 3.4 二进制运算符二进制位运算符用于直接对二进制位进行计算，一共有7个。 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。 二进制否运算符（not）：符号为~，表示对一个二进制位取反。 异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。 左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。 右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。 带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。 （未完待续） 3.5 其他运算符，运算顺序3.5.1 void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 请看下面的代码。123456&lt;script&gt;function f() &#123; console.log('Hello World');&#125;&lt;/script&gt;&lt;a href=\"http://example.com\" onclick=\"f(); return false;\"&gt;点击&lt;/a&gt; 上面代码中，点击链接后，会先执行onclick的代码，由于onclick返回false，所以浏览器不会跳转到 example.com。 void运算符可以取代上面的写法。1&lt;a href=\"javascript: void(f())\"&gt;文字&lt;/a&gt; 下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。123&lt;a href=\"javascript: void(document.form.submit())\"&gt; 提交&lt;/a&gt; 3.5.2 逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。 逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。 3.5.3 运算顺序左结合与右结合最主要的是赋值运算符（=）和三元条件运算符（?:）。 12w = x = y = z;q = a ? b : c ? d : e ? f : g; 上面代码的运算结果，相当于下面的样子。 12w = (x = (y = z));q = a ? b : (c ? d : (e ? f : g)); 上面的两行代码，各有三个等号运算符和三个三元运算符，都是先计算最右边的那个运算符。 指数运算符（**）也是右结合的。123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript学习笔记（一）——基本语法、数据类型","date":"2018-11-12T03:06:57.678Z","path":"2018/11/12/javascript_1/","text":"来自教程 https://wangdoc.com/javascript/basic/index.html 1 基本语法1.1 语句(略) 1.2 变量(略) 1.2.1 变量提升(略) 1.3 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 1.4 注释(略) 1.5 区块(略) 1.6 条件语句 if…else switch 三元运算符 (略) 1.7 循环语句(略) 1.7.1 for(略) 1.7.2 while(略) 1.7.3 do…while(略) 1.7.4 break和continue(略) 1.7.5 标签(label)(略) 2 数据类型2.1 类型JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 狭义的对象（object） 数组（array） 函数（function） 原始类型（primitive type）：数值、字符串、布尔值。 合成类型（complex type）：对象。 特殊值：null、undefined。 2.2 typeof 运算符typeof运算符可以返回一个值的数据类型。 123456789101112131415typeof 123 // \"number\" 数值返回numbertypeof '123' // \"string\" 字符串返回stringtypeof false // \"boolean\" 布尔值返回booleanfunction f() &#123;&#125;typeof f // \"function\" 函数返回functiontypeof undefined // \"undefined\" undefined返回undefined//对象返回objecttypeof window // \"object\"typeof &#123;&#125; // \"object\"typeof [] // \"object\"typeof null // \"object\" null返回object 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// \"undefined\" 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123;// ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === \"undefined\") &#123;// ...&#125; 2.3 null 和 undefined 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false');&#125;// null is falseundefined == null// true null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 1234Number(null) // 05 + null // 5Number(undefined) // NaN5 + undefined // NaN null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2.4 布尔值下列运算符会返回布尔值： 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 123456undefinednullfalse0NaN\"\"或''（空字符串） 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 2.5 数值（未完待续） 2.6 字符串2.6.1 用法单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12'key = \"value\"'\"It's a long journey\" HTML语言的属性值使用双引号，JavaScript语言的字符串只使用单引号。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \\long \\long \\string';longString// \"Long long long string\" 如果想输出多行字符串，有一种利用多行注释的变通方法。12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\\n').slice(1, -1).join('\\n')// \"line 1// line 2// line 3\" 2.6.2 转义(未完待续) 2.6.3 字符串与数组 字符串可以被视为字符数组。 1234567var s = 'hello';s[0] // \"h\"s[1] // \"e\"s[4] // \"o\"// 直接对字符串使用方括号运算符'hello'[1] // \"e\" 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123'abc'[3] // undefined'abc'[-1] // undefined'abc'['x'] // undefined 无法改变字符串之中的单个字符。12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 2.6.4 字符集（未完待续） 2.6.5 Base 64转码（未完待续） 2.7 对象2.7.1 含义键名 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。 如果键名是数值，会被自动转为字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的引用o1和o2指向同一个对象，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 表达式还是语句？1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。 第一种可能是，这是一个表达式，表示一个包含foo属性的对象； 第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定： 如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号: 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2.7.2 属性的操作属性的读取12345678910111213141516171819202122var foo = 'bar';var obj = &#123; p: 'Hello World', bar: 2, 'hello world':3, 6:'num_key', 0.7: 'Hello World', 123: 'hello 123'&#125;;obj.p // \"Hello World\" 使用点运算符obj['p'] // \"Hello World\" 方括号运算符,键名必须放在引号里面，否则会被当作变量处理。obj[foo] // 2 键名为变量// 方括号运算符内部还可以使用表达式obj['hello' + ' world'] //3obj[3 + 3] //num_key// 数字键可以不加引号，因为会自动转成字符串。obj['0.7'] // \"Hello World\"obj[0.7] // \"Hello World\"obj.123 // 报错 数值键名不能使用点运算符obj[123] // \"hello 123\" 属性的赋值（略） 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。12Object.keys(obj);// [\"6\", \"123\", \"p\", \"bar\", \"hello world\", \"0.7\"] 属性的删除1delete obj.p // true 删除一个不存在的属性，delete不报错，而且返回true 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 12345var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, configurable: false&#125;);delete obj.p // false delete命令只能删除对象本身的属性，无法删除继承的属性,虽然delete命令返回true，但该属性并没有被删除，依然存在。 in 运算符————属性是否存在123var obj = &#123; p: 1 &#125;;'p' in obj // true'toString' in obj // true in运算符不能区分哪些属性是对象自身的，还是继承的。 就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断是否为对象自身的属性。 for…in ————属性的遍历1234567891011var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 两个使用注意点: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 只想遍历对象自身的属性，结合使用hasOwnProperty方法：12345for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125; 2.7.3 with语句操作同一个对象的多个属性时，提供一些书写的方便。 不推荐使用！！！ 2.8 函数2.8.1 概述函数声明三种声明函数的方式： （1）function 命令123function print(s) &#123; console.log(s);&#125; （2）函数表达式123var print = function(s) &#123; console.log(s);&#125;; function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 （3）Function 构造函数12345var add = new Function( 'x', 'y', 'return x + y'); 函数的重复声明 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。 函数名的提升 采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。 如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 1234567var f = function () &#123; console.log('1');&#125;function f() &#123; console.log('2');&#125;f() // 1 2.8.2 函数的属性和方法name 属性 如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 length 属性 函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 2.8.3 函数作用域函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。123456789var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 2.8.4 参数传递方式1、 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。123456var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 2、 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。123456var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 3、 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。123456var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 arguments 对象 正常模式下，arguments对象可以在运行时修改。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组: 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 2.8.5 函数的其他知识点闭包function f1() { var n = 999; function f2() { console.log(n); } return f2;} var result = f1();result(); // 999上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 12345678910function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE）12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，就是将其放在一个圆括号里面。123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个： 一是不必为函数命名，避免了污染全局变量； 二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 2.8.6 eval 命令eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 所以一般不推荐使用！！！ 2.9 数组2.9.1 length属性由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。1234567var a = [];a['p'] = 'abc';a.length // 0a[2.1] = 'abc';a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 2.9.2 in运算符2.9.3 for…in 循环和数组的遍历 在遍历数组时，也遍历到了数字键之外的其他键，所以，不推荐使用for…in遍历数组。 数组的遍历可以考虑使用for循环或while循环。 数组的forEach方法，也可以用来遍历数组。 2.9.4数组的空位 数组的空位不影响length属性。 如果最后一个元素后面有逗号，并不会产生空位。 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。 如果某个位置是undefined，遍历的时候就不会被跳过。 2.9.5 类似数组的对象 “类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性，这种length属性不是动态值，不会随着成员的变化而变化。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 1234function print(value, index) &#123; console.log(index + ' : ' + value);&#125;Array.prototype.forEach.call(arrayLike, print); 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用Hexo+Github.io构建自己的博客","date":"2018-11-03T16:00:00.000Z","path":"2018/11/04/Hexo-Github-io-blog/","text":"背景知识Github Page是什么Github是全球最大的开源社区，Github Page是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上。 Hexo是什么你可以将你的静态页面直接放在Github Page上，也可以用Hexo或者Jekyll等博客框架自动生成站点。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 基础构建步骤1、 安装Node.js，并配置好Node.js环境。 2、 安装Git，并配置好Git环境。 3、 如果没有Github账户，先注册Github账户，然后新建项目，项目必须要遵守格式:“Github账户名.github.io”，这样能够防止接下来的很多麻烦。访问“http://Github账户名.github.io” ，发现网址已经可以通过网络访问。 4、 安装Hexo。 ① 安装Hexo，在自己认为合适的地方创个文件夹，例如在E盘创建hexo_test文件夹。然后通过cd命令行进入到该文件夹里面。 ② 输入npm install hexo -g，开始安装Hexo。安装完成后可以输入hexo -v，检查hexo是否安装成功，安装成功会有类似如下输出： ③ 输入hexo init，初始化该文件夹,看到输出“Start blogging with Hexo！”，表明初始化成功： ④ 输入npm install，安装所需要的组件，等待安装完成。 ⑤ 输入hexo g，生成网站静态文件。 ⑥ 输入hexo s，开启本地服务器： 端口号存在被占用的可能，可以在服务器停止的情况下，输入“hexo server -p 端口号”来改变端口号。按照上面提示，在浏览器访问http://localhost:4000/，打开类似下图网页，证明Hexo本地服务器启动成功。 (未完待续)参考资料https://blog.csdn.net/peterzhen40/article/details/78942293 https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/cf0628478a4e","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github.io","slug":"Github-io","permalink":"http://yoursite.com/tags/Github-io/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"React 学习笔记","date":"2018-11-03T06:52:11.000Z","path":"2018/11/03/React/","text":"","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"webpack 学习笔记（一）","date":"2018-11-03T06:52:11.000Z","path":"2018/11/03/webpack_1/","text":"本文主要参考文章： 《入门 Webpack，看这篇就够了》 开始使用Webpack我们一步步的开始学习使用Webpack。 安装新建一个空的练习文件夹（此处命名为webpack-base-demo）。 切换到webpack-base-demo文件夹，在终端中使用npm init命令可以自动创建package.json文件，package.json文件这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。 1npm init 输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。 package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包12345// 安装Webpacknpm install --save-dev webpack// 安装webpack-clinpm install --save-dev webpack-cli 回到webpack-base-demo文件夹，并在里面创建app文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，接下来我们在app文件夹中创建两个文件: 12index.jsindex.css index.js文件内容： 123window.onload = function()&#123; document.getElementById('div1').textContent=\"Hello world\";&#125; 在webpack-base-demo文件夹里面创建dist文件夹，dist文件夹中创建index.html，index.html文件中写入最基础的html代码： 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" class=\"div1\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。 继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。 1234567module.exports = &#123; entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 在package.json中对scripts对象进行相关设置即可，设置方法如下。 12345678910111213141516&#123; \"name\": \"webpack-base-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\" // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^4.25.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125; 注：package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build。 现在只需要使用npm start就可以打包文件了,可以发现在dist文件夹中生成了index.js文件。 Webpack的强大功能生成Source Maps（使调试更容易）开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，Source Maps就是来帮我们解决这个问题的。 通过简单的配置，webpack就可以在打包时为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。 在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下： devtool选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； 正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。 对小到中型的项目中，eval-source-map是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的webpack.config.js，进行如下配置: 12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", output: &#123; path: __dirname + \"/dist\", filename: \"index.js\" &#125;&#125; cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。 使用webpack构建本地服务器想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖 1npm install --save-dev webpack-dev-server devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考这里 devserver的配置选项 功能描述 contentBase 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“dist”目录） port 设置默认监听端口，如果省略，默认为”8080“ inline 设置为true，当源文件改变时会自动刷新页面 historyApiFallback 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html 把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示 1234567891011121314module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", output: &#123; path: __dirname + \"/dist\", filename: \"index.js\" &#125;, devServer: &#123; contentBase: \"./dist\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125; &#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\", \"server\": \"webpack-dev-server --open --mode development\"&#125;, 在终端中输入npm run server即可在本地的8080端口查看结果,成功后页面显示“Hello world”。 LoadersLoaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 不过在配置loader之前，我们把index.js里的“Hello world”放在一个单独的JSON文件里,并通过合适的配置使index.js可以读取该JSON文件的值，各文件修改后的代码如下： 在app文件夹中创建带有问候信息的JSON文件(命名为config.json) 123&#123; \"greetText\": \"Hello world\"&#125; 更新后的index.js 1234import config from './config.json';window.onload = function()&#123; document.getElementById('div1').textContent=config.greetText;&#125; 注 由于webpack4. / webpack3. / webpack2. 已经内置可处理JSON文件，这里我们无需再添加webpack1.需要的json-loader。在看如何具体使用loader之前我们先看看Babel是什么？ BabelBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的： 让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持； 让你能使用基于JavaScript进行了拓展的语言，比如React的JSX； Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包，用得最多的是解析Es6的babel-env-preset包。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env 在webpack中配置Babel的方法如下: 12345678910111213141516171819202122232425262728module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.js)$/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"env\" ] &#125; &#125;, exclude: /node_modules/ &#125;] &#125;&#125; 现在你的webpack的配置已经允许你使用ES6了，运行npm start，提示如下错误：12345678ERROR in ./app/index.jsModule build failed (from ./node_modules/babel-loader/lib/index.js):Error: Cannot find module '@babel/core' babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to use Babel6.x ('babel-core'), you should install 'babel-loader@7'. at Function.Module._resolveFilename (module.js:547:15) at Function.Module._load (module.js:474:25) at Module.require (module.js:596:17) 原因是版本babel-loader的版本为8.x，匹配的Babel的版本为7.x，查看package.json文件，babel-core的版本为6.26.3，我们采取的解决办法是将重新安装版本为7.x的babel-loader，重新运行npm start 就没问题了。 增加React的支持安装解析JSX的babel-preset-react包： 1npm install --save-dev babel-preset-react webpack.config.js中更新module如下： 1234567891011121314module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [ \"env\", \"react\" ] &#125; &#125;, exclude: /node_modules/ &#125;]&#125; 现在webpack的配置已经允许使用JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM1npm install --save-dev react react-dom 接下来我们使用ES6的语法，APP文件夹中新建Greeter.js文件并返回一个React组件123456789101112131415//Greeter.jsimport React, &#123;Component&#125; from 'react'import config from './config.json';class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 修改index.js如下，使用ES6的模块定义和渲染Greeter模块 123456// index.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';render(&lt;Greeter /&gt;, document.getElementById('div1')); 重新使用npm start打包，并且运行npm run server，你应该可以在localhost:8080下看到与之前一样的内容，这说明react被正常打包了。 Babel的配置Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：123456789101112131415161718192021222324module.exports = &#123; entry: __dirname + \"/app/index.js\",//已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\",//打包后的文件存放的地方 filename: \"index.js\"//打包后输出文件的文件名 &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: \"./dist\",//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125; ] &#125;&#125;; 1234//.babelrc&#123; \"presets\": [\"react\", \"env\"]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 一切皆模块Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子12//安装npm install --save-dev style-loader css-loader 1234567891011121314151617181920212223242526//使用module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125; ] &#125;&#125;; 请注意这里对同一个文件引入多个loader的方法。 接下来，在app文件夹里的index.css文件中，对一些元素设置样式 1234/* index.css */div&#123; color:green;&#125; 我们这里例子中用到的webpack只有单一的入口，其它的模块需要通过 import, require, url等与入口文件建立其关联，为了让webpack能找到index.css文件，我们把它导入index.js中，如下 1234567//index.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';import './index.css'; //使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById('div1')); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 上面的代码说明webpack是怎么把css当做模块看待的，咱们继续看一个更加真实的css模块实践。 CSS module在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。 不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。 被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下123456789101112131415161718192021222324252627282930module.exports = &#123; ... module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125; ] &#125;&#125;; 我们在app文件夹下创建一个Greeter.css文件来进行一下测试1234/* Greeter.css */.by&#123; background-color: yellow;&#125; 导入.root到Greeter.js中123456789101112131415import React, &#123;Component&#125; from 'react';import config from './config.json';import styles from './Greeter.css';//导入class Greeter extends Component&#123; render() &#123; return ( &lt;div className=&#123;styles.by&#125;&gt; //使用cssModule添加类名的方法 &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 重新运行npm start打包，运行npm run server，打开localhost:8080，文字背景变为黄色，div的class为“Greeter__by–U44rR”这样的形式，这样就可以保证不同组件之间不会存在相同的类名。 CSS预处理器(后续补充) 插件（Plugins）插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件(https://webpack.js.org/plugins/)，可以让我们完成更加丰富的功能。 使用插件的方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件BannerPlugin。123456789101112131415161718192021222324252627282930const webpack = require('webpack'); //引入webpackmodule.exports = &#123;... module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究') ],&#125;; 通过这个插件，打包后的JS文件显示如下 1234567/*! 版权所有，翻版必究 *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123; 这就是webpack插件的基础用法了，下面给大家推荐几个常用的插件. HtmlWebpackPlugin这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。 安装1npm install --save-dev html-webpack-plugin 这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改： 移除dist文件夹，利用此插件，index.html文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。 在app目录下，创建一个index.tmpl.html文件模板，这个模板包含title等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，index.tmpl.html中的模板源代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\" class=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 更新webpack的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ],&#125; 再次执行npm start你会发现，dist文件夹会重新生成，并文件夹下面生成了index.js和index.html。 Hot Module Replacement（后续补充） 产品阶段的构建目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。 对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个webpack.production.config.js的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'null', //注意修改了这里，这能大大压缩我们的打包代码 entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ],&#125; 123456789101112131415161718192021222324252627282930//package.json&#123; \"name\": \"webpack-base-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack --mode development\", \"server\": \"webpack-dev-server --open --mode development\", \"build\": \"NODE_ENV=production webpack --config ./webpack.production.config.js --progress\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-preset-env\": \"^1.7.0\", \"babel-preset-react\": \"^6.24.1\", \"css-loader\": \"^1.0.1\", \"html-webpack-plugin\": \"^3.2.0\", \"react\": \"^16.6.1\", \"react-dom\": \"^16.6.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.25.1\", \"webpack-cli\": \"^3.1.2\", \"webpack-dev-server\": \"^3.1.10\" &#125;, \"dependencies\": &#123;&#125;&#125; 注意：如果是window电脑，build需要配置为”build”: “set NODE_ENV=production &amp;&amp; webpack –config ./webpack.production.config.js –progress”。谢谢评论区简友提醒。 优化插件webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能 OccurenceOrderPlugin：为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID UglifyjsWebpackPlugin：压缩JS代码； ExtractTextPlugin：分离CSS和JS文件（暂时不支持webpack 4，本文档不予讨论） 我们继续用例子来看看如何添加它们，OccurenceOrder是内置插件，你需要做的只是安装其它非内置插件 1npm install --save-dev uglifyjs-webpack-plugin 在配置文件的plugins后引用它们1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');// extract-text-webpack-plugin暂时不支持webpack4// const ExtractTextPlugin = require('extract-text-webpack-plugin');const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; devtool: 'null', //注意修改了这里，这能大大压缩我们的打包代码 entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index.js\" //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: \"./dist\", //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: \"babel-loader\" &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true, // 指定启用css modules localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式 &#125; &#125; ] &#125;] &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new UglifyjsWebpackPlugin(), // extract-text-webpack-plugin暂时不支持webpack4 // new ExtractTextPlugin(\"style.css\"), ],&#125; 此时执行npm run build可以看见代码是被压缩后的。 缓存缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变） webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前 12345678910111213141516// webpack.production.config.jsconst webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');// extract-text-webpack-plugin暂时不支持webpack4// const ExtractTextPlugin = require('extract-text-webpack-plugin');const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123;... entry: __dirname + \"/app/index.js\", //已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/dist\", //打包后的文件存放的地方 filename: \"index-[hash].js\" //打包后输出文件的文件名 &#125;, ...&#125; 现在用户会有合理的缓存了。 去除dist文件中的残余文件添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件clean-webpack-plugin。 安装： 1npm install clean-webpack-plugin --save-dev 使用： 引入clean-webpack-plugin插件后在配置文件的plugins中做相应配置即可： 123456789const CleanWebpackPlugin = require(\"clean-webpack-plugin\"); plugins: [ ...// 这里是之前配置的其它各种插件 new CleanWebpackPlugin('dist/*.*', &#123; root: __dirname, verbose: true, dry: false &#125;) ] 关于clean-webpack-plugin的详细使用可参考这里。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]}]